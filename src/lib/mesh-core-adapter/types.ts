/**
 * Maximum loadable file size (600 MB)
 * 
 * Files exceeding this value will return an E_FILE_TOO_LARGE error.
 * 
 * @see AdapterErrorCode.E_FILE_TOO_LARGE
 */
export const MAX_MESH_FILE_BYTES = 629_145_600; // 600 MB guardrail

/**
 * Maximum loadable triangle count (30 million)
 * 
 * Meshes exceeding this value will return an E_TOO_MANY_TRIANGLES error.
 * 
 * @see AdapterErrorCode.E_TOO_MANY_TRIANGLES
 */
export const MAX_TRIANGLE_COUNT = 30_000_000;  // 30 million

/**
 * Supported mesh file formats
 * 
 * - `obj`: Wavefront OBJ (ASCII)
 * - `stl`: ASCII STL
 * - `stl_binary`: Binary STL
 * - `ply_ascii`: ASCII PLY
 * - `ply_binary_le`: Binary PLY (Little Endian)
 * - `ply_binary_be`: Binary PLY (Big Endian)
 * 
 * @see MeshAsset.format
 */
export type MeshFormat = 'obj' | 'stl' | 'stl_binary' | 'ply_ascii' | 'ply_binary_le' | 'ply_binary_be';

/**
 * Mesh vertex/index/normal buffers
 * 
 * TypedArray views managed in WASM memory.
 * Must call `release()` to free memory after use.
 * 
 * @example
 * ```typescript
 * const { buffers } = asset;
 * console.log('Vertices:', buffers.vertexView.length / 3);
 * 
 * // Release buffers after use
 * buffers.release();
 * ```
 */
export interface MeshBuffers {
  /**
   * Vertex coordinate array (x, y, z sequential)
   * 
   * Length is vertex count × 3.
   * Uses Float64Array for precise coordinates.
   */
  vertexView: Float64Array;
  
  /**
   * Triangle index array (3 indices per triangle)
   * 
   * Length is triangle count × 3.
   */
  indexView: Uint32Array;
  
  /**
   * Vertex normal array (nx, ny, nz sequential, optional)
   * 
   * Undefined if file does not contain normal information.
   */
  normalView?: Float32Array;
  
  /**
   * WASM buffer generation number
   * 
   * Increments whenever the same buffer is modified.
   * Used by renderer to detect buffer changes.
   */
  generation: number;
  
  /**
   * Buffer release function
   * 
   * Frees WASM heap memory.
   * Must be called when asset usage is complete.
   */
  release: () => void;
}

/**
 * Mesh statistics information
 * 
 * Includes basic statistics such as vertex count, triangle count, and bounding box.
 */
export interface MeshStats {
  /** Vertex count */
  vertices: number;
  
  /** Triangle count */
  triangles: number;
  
  /**
   * Bounding box (Axis-Aligned Bounding Box)
   * 
   * min: Minimum coordinates [x, y, z]
   * max: Maximum coordinates [x, y, z]
   */
  bbox: {
    min: [number, number, number];
    max: [number, number, number];
  };
  
  /**
   * Bounding box diagonal length
   * 
   * Used for camera placement and Fit-to-View calculations.
   */
  diagonalLength: number;
}

/**
 * Normalized mesh data
 * 
 * All parser outputs (STL, OBJ, PLY) are converted to this structure.
 * Upper layers can use mesh data in a consistent structure regardless of file format.
 * 
 * @example
 * ```typescript
 * if (result.status === 'success') {
 *   const asset = result.asset;
 *   console.log(`File: ${asset.fileName}`);
 *   console.log(`Format: ${asset.format}`);
 *   console.log(`Triangles: ${asset.stats?.triangles}`);
 *   console.log(`Load time: ${asset.loadDurationMs}ms`);
 *   
 *   // Use buffers
 *   const vertices = asset.buffers.vertexView;
 *   // ...
 *   
 *   // Release after use
 *   asset.buffers.release();
 * }
 * ```
 */
export interface MeshAsset {
  /**
   * Unique identifier (UUID v4 format)
   * 
   * Generated by crypto.randomUUID().
   */
  id: string;
  
  /** Original filename (with extension) */
  fileName: string;
  
  /** File size (bytes) */
  fileSizeBytes: number;
  
  /** Detected file format */
  format: MeshFormat;
  
  /** Load completion time (Unix timestamp, milliseconds) */
  loadedAt: number;
  
  /** Load duration (milliseconds) */
  loadDurationMs: number;
  
  /** Vertex/index/normal buffers */
  buffers: MeshBuffers;
  
  /** Mesh statistics (bbox, vertex/face count, etc.) */
  stats?: MeshStats;
}

export type ViewerStateStatus = 'Idle' | 'Loading' | 'Ready' | 'Error';

export interface ViewerCameraState {
  target: [number, number, number];
  distance: number;
  azimuth: number;
  elevation: number;
}

export interface OverlayToggles {
  solid: boolean;
  smooth: boolean;
  wireframe: boolean;
  vertices: boolean;
  normals: boolean;
  bbox: boolean;
}

export interface ViewerError {
  code: string;
  message: string;
}

export interface ViewerState {
  status: ViewerStateStatus;
  activeAssetId: string | null;
  camera: ViewerCameraState;
  overlays: OverlayToggles;
  fitToView: boolean;
  error?: ViewerError;
}

export interface MeshCoreCapabilities {
  binaryPlyEnabled: boolean;
  wasmVersion: string;
}

// ============================================================================
// Observability Contracts (003-mesh-core-adapter)
// ============================================================================

/**
 * Log level
 * 
 * - `DEBUG`: Detailed debugging info (parsing start/end, format detection, etc.)
 * - `INFO`: General information (load success, etc.)
 * - `WARN`: Warnings (format mismatch, Fast→Exact fallback, etc.)
 * - `ERROR`: Errors (parsing failure, file read failure, etc.)
 * 
 * @see LogEvent
 * @see LogEvent.schema.json
 */
export type LogLevel = 'DEBUG' | 'INFO' | 'WARN' | 'ERROR';

/**
 * Log context - extensible additional information
 * 
 * Contains structured metadata for log events.
 * Extensible via `[key: string]: unknown`.
 * 
 * @example
 * ```typescript
 * const context: LogContext = {
 *   category: 'adapter',
 *   op: 'parse_mesh',
 *   elapsed_ms: 123.45,
 *   fileId: 'abc-123',
 *   customField: 'any value'  // Extension field
 * };
 * ```
 */
export interface LogContext {
  /**
   * Log category
   * 
   * - `io`: File I/O operations
   * - `adapter`: Adapter internal processing
   * - `robustness`: Fast→Exact fallback and robustness related
   * - `bench`: Benchmark/performance measurement
   * - `wasm`: WASM module related (SharedArrayBuffer, etc.)
   */
  category?: 'io' | 'adapter' | 'robustness' | 'bench' | 'wasm';
  
  /**
   * Operation name
   * 
   * e.g., 'import_stl', 'parse_mesh', 'detect_format', 'fallback_exact'
   */
  op?: string;
  
  /**
   * Elapsed time (milliseconds)
   * 
   * Records operation completion time.
   */
  elapsed_ms?: number;
  
  /**
   * Related error/success code
   * 
   * e.g., 'E_PARSE_FAILED', 'Success'
   */
  code?: string;
  
  /**
   * Related file ID
   * 
   * Used to distinguish per-file logs during concurrent loads.
   */
  fileId?: string;
  
  /** Extensible additional fields */
  [key: string]: unknown;
}

/**
 * Single log entry
 * 
 * Maps one-to-one with TypeScript LogEvent type and C++ AdapterLogEvent struct.
 * Conforms to LogEvent.schema.json and validated by Ajv.
 * 
 * @example
 * ```typescript
 * const event: LogEvent = {
 *   level: 'INFO',
 *   message: 'Mesh loaded successfully',
 *   timestamp: '2025-12-02T10:30:00.000Z',
 *   context: {
 *     category: 'io',
 *     op: 'load_complete',
 *     elapsed_ms: 123.45
 *   }
 * };
 * ```
 * 
 * @see LogEvent.schema.json
 * @see MeshCoreAdapter.onLog
 */
export interface LogEvent {
  /** Log level (DEBUG, INFO, WARN, ERROR) */
  level: LogLevel;
  
  /** Log message (minimum 1 character) */
  message: string;
  
  /**
   * ISO 8601 UTC timestamp
   * 
   * e.g., '2025-12-02T10:30:00.000Z'
   */
  timestamp: string;
  
  /** Additional context (optional) */
  context?: LogContext;
}

/**
 * Adapter error code
 * 
 * Follows `E_` prefix + SCREAMING_SNAKE_CASE format.
 * Matches the enum in AdapterError.schema.json.
 * 
 * ## Error Codes by Category
 * 
 * **File I/O**:
 * - `E_EMPTY_FILE`: 0-byte empty file
 * - `E_FILE_TOO_LARGE`: Exceeds 600MB
 * - `E_FILE_READ_FAILED`: File read failure
 * 
 * **Parse**:
 * - `E_PARSE_FAILED`: Parse failure (both Fast/Exact)
 * - `E_UNSUPPORTED_FORMAT`: Unsupported format
 * 
 * **Memory**:
 * - `E_MEMORY_LIMIT`: WASM memory limit exceeded
 * 
 * **Network**:
 * - `E_FETCH_FAILED`: URL fetch failure
 * - `E_FETCH_TIMEOUT`: Network timeout
 * 
 * **Validation**:
 * - `E_INVALID_MESH`: Invalid mesh data
 * - `E_TOO_MANY_TRIANGLES`: Triangle count exceeded (30 million)
 * 
 * @see AdapterError
 * @see AdapterError.schema.json
 */
export type AdapterErrorCode =
  // File I/O
  | 'E_EMPTY_FILE'
  | 'E_FILE_TOO_LARGE'
  | 'E_FILE_READ_FAILED'
  // Parse
  | 'E_PARSE_FAILED'
  | 'E_UNSUPPORTED_FORMAT'
  // Memory
  | 'E_MEMORY_LIMIT'
  // Network
  | 'E_FETCH_FAILED'
  | 'E_FETCH_TIMEOUT'
  // Validation
  | 'E_INVALID_MESH'
  | 'E_TOO_MANY_TRIANGLES';

/**
 * Error Context - Additional information per error type
 * 
 * Contains relevant context information based on error code.
 * 
 * ## Context Fields by Error Code
 * 
 * | Error Code | Context Fields |
 * |------------|----------------|
 * | E_EMPTY_FILE | fileName |
 * | E_FILE_TOO_LARGE | fileName |
 * | E_MEMORY_LIMIT | requiredBytes, availableBytes |
 * | E_TOO_MANY_TRIANGLES | triangleCount, maxTriangles, fileName |
 * | E_UNSUPPORTED_FORMAT | format, fileName |
 * 
 * @example
 * ```typescript
 * // Context for E_MEMORY_LIMIT error
 * const context: ErrorContext = {
 *   requiredBytes: 500_000_000,
 *   availableBytes: 400_000_000
 * };
 * ```
 */
export interface ErrorContext {
  /** Related file name */
  fileName?: string;
  
  /**
   * Required memory in bytes (E_MEMORY_LIMIT)
   * 
   * Estimated memory size required to load the mesh.
   */
  requiredBytes?: number;
  
  /**
   * Available memory in bytes (E_MEMORY_LIMIT)
   * 
   * Memory size currently available in the WASM heap.
   */
  availableBytes?: number;
  
  /**
   * Triangle count (E_TOO_MANY_TRIANGLES)
   * 
   * Actual number of triangles contained in the file.
   */
  triangleCount?: number;
  
  /**
   * Maximum allowed triangle count (E_TOO_MANY_TRIANGLES)
   * 
   * Value of the MAX_TRIANGLE_COUNT constant.
   */
  maxTriangles?: number;
  
  /** Error reason (detailed) */
  reason?: string;
  
  /** Format information (E_UNSUPPORTED_FORMAT) */
  format?: string;
}

/**
 * Adapter error object
 * 
 * JSON Schema validatable error structure.
 * Conforms to AdapterError.schema.json.
 * 
 * @example
 * ```typescript
 * if (result.status === 'error') {
 *   const error = result.error;
 *   console.error(`[${error.severity}] ${error.code}: ${error.message}`);
 *   
 *   if (error.code === 'E_MEMORY_LIMIT' && error.context) {
 *     console.error(`Required: ${error.context.requiredBytes} bytes`);
 *     console.error(`Available: ${error.context.availableBytes} bytes`);
 *   }
 * }
 * ```
 * 
 * @see AdapterError.schema.json
 * @see AdapterErrorCode
 */
export interface AdapterError {
  /**
   * Error code (E_ prefix)
   * 
   * One of 10 error codes.
   */
  code: AdapterErrorCode;
  
  /**
   * Human-readable message
   * 
   * Must be at least 1 character.
   */
  message: string;
  
  /**
   * Severity
   * 
   * - `error`: Serious error indicating operation failure
   * - `warn`: Warning (operation may continue)
   */
  severity: 'error' | 'warn';
  
  /**
   * ISO 8601 UTC timestamp
   * 
   * Records when the error occurred.
   */
  timestamp: string;
  
  /**
   * Additional context information
   * 
   * Contains different fields based on error code.
   */
  context?: ErrorContext;
}

/**
 * Performance and quality metrics
 * 
 * Collected from all load operations, included in MeshLoadResult regardless of success/failure.
 * Conforms to AdapterMetrics.schema.json.
 * 
 * @example
 * ```typescript
 * const metrics = result.metrics;
 * console.log(`File ID: ${metrics.fileId}`);
 * console.log(`Parse time: ${metrics.parseTimeMs}ms`);
 * console.log(`Parser mode: ${metrics.parserMode}`);
 * console.log(`Fallback count: ${metrics.fallbackCount}`);
 * 
 * // Calculate throughput
 * const triPerSec = metrics.triangleCount / (metrics.parseTimeMs / 1000);
 * console.log(`Throughput: ${triPerSec.toFixed(0)} tri/s`);
 * ```
 * 
 * @see AdapterMetrics.schema.json
 */
export interface AdapterMetrics {
  /**
   * Unique file ID (for concurrent load distinction)
   * 
   * Generated in UUID v4 format.
   * Distinguishes metrics when loading multiple files simultaneously.
   */
  fileId: string;
  
  /**
   * Parse duration (milliseconds)
   * 
   * Time spent only on parsing file data.
   * Measured using performance.now().
   */
  parseTimeMs: number;
  
  /**
   * Total load time (milliseconds)
   * 
   * Total time from load() call to result return.
   */
  totalTimeMs: number;
  
  /** Vertex count */
  vertexCount: number;
  
  /** Triangle count */
  triangleCount: number;
  
  /**
   * Parser mode used
   * 
   * - `fast`: Successfully parsed in Fast mode
   * - `exact`: Parsed in Exact mode after Fast failure
   */
  parserMode: 'fast' | 'exact';
  
  /**
   * Fallback occurrence count (0 or 1)
   * 
   * 1 if Fast→Exact fallback occurred, 0 otherwise.
   * Maximum 1 fallback allowed (spec FR-003).
   */
  fallbackCount: number;
  
  /** Bytes read */
  bytesRead: number;
}

/**
 * Load operation result wrapper
 * 
 * Contains `asset` or `error` based on `status` value:
 * - `status === 'success'` → `asset` required, no `error`
 * - `status === 'error'` → `error` required, no `asset`
 * 
 * `metrics` and `logs` are always present.
 * 
 * @example
 * ```typescript
 * const result = await adapter.load(file);
 * 
 * // Type guard based handling
 * if (result.status === 'success') {
 *   // result.asset is inferred as MeshAsset
 *   console.log('Loaded:', result.asset.fileName);
 * } else {
 *   // result.error is inferred as AdapterError
 *   console.error('Error:', result.error.code);
 * }
 * 
 * // Metrics and logs are always available
 * console.log('Time:', result.metrics.totalTimeMs, 'ms');
 * console.log('Logs:', result.logs.length, 'events');
 * ```
 * 
 * @see MeshLoadResult.schema.json
 */
export interface MeshLoadResult {
  /**
   * Operation result status
   * 
   * - `success`: Load successful - `asset` field exists
   * - `error`: Load failed - `error` field exists
   */
  status: 'success' | 'error';
  
  /**
   * Loaded asset on success
   * 
   * Only exists when `status === 'success'`.
   */
  asset?: MeshAsset;
  
  /**
   * Error object on failure
   * 
   * Only exists when `status === 'error'`.
   */
  error?: AdapterError;
  
  /**
   * Performance metrics (always included)
   * 
   * Always collected regardless of success/failure.
   */
  metrics: AdapterMetrics;
  
  /**
   * All logs from load process
   * 
   * Array of LogEvents sorted chronologically.
   */
  logs: LogEvent[];
}

// ============================================================================
// Legacy Types (Deprecated - will be removed in v1.0)
// ============================================================================
//
// The types below are maintained for backward compatibility.
// Use the new types above in new code:
//   - MeshLoadTelemetry → AdapterMetrics
//   - MeshLoadSuccess/MeshLoadFailure → MeshLoadResult
//   - LegacyMeshLoadResult → MeshLoadResult
// ============================================================================

/**
 * Load Performance Telemetry (Legacy)
 * 
 * @deprecated Scheduled for removal in v1.0. Use {@link AdapterMetrics} instead.
 * The new type provides additional fields: parserMode, vertexCount, triangleCount, fileId.
 * 
 * @example
 * ```typescript
 * // Legacy code (deprecated)
 * const telemetry: MeshLoadTelemetry = {
 *   loadDurationMs: 50,
 *   bytesRead: 50000,
 *   fallbackCount: 0,
 * };
 * 
 * // New code (recommended)
 * const metrics: AdapterMetrics = {
 *   fileId: crypto.randomUUID(),
 *   parseTimeMs: 50,
 *   totalTimeMs: 60,
 *   vertexCount: 1000,
 *   triangleCount: 2000,
 *   parserMode: 'fast',
 *   fallbackCount: 0,
 *   bytesRead: 50000,
 * };
 * ```
 * 
 * @see AdapterMetrics
 */
export interface MeshLoadTelemetry {
  /** Load duration (ms) - Replaced by AdapterMetrics.totalTimeMs */
  loadDurationMs: number;
  /** Bytes read */
  bytesRead: number;
  /** Fallback occurrence count */
  fallbackCount: number;
}

/**
 * Legacy Error Code (Legacy)
 * 
 * @deprecated Scheduled for removal in v1.0. Use {@link AdapterErrorCode} instead.
 * The new error codes provide 10 granular error types.
 * 
 * @example
 * ```typescript
 * // Legacy → New code mapping
 * // 'UnsupportedFormat.binary_ply' → 'E_UNSUPPORTED_FORMAT'
 * // 'UnsupportedAsset.too_large' → 'E_FILE_TOO_LARGE'
 * // 'UnsupportedAsset.too_many_triangles' → 'E_TOO_MANY_TRIANGLES'
 * // 'Core.initialization_failed' → 'E_MEMORY_LIMIT' or related error
 * // 'Core.parse_failed' → 'E_PARSE_FAILED'
 * ```
 * 
 * @see AdapterErrorCode
 */
export type MeshLoadErrorCode =
  | 'UnsupportedFormat.binary_ply'
  | 'UnsupportedAsset.too_large'
  | 'UnsupportedAsset.too_many_triangles'
  | 'Core.initialization_failed'
  | 'Core.parse_failed';

/**
 * Success Result (Legacy)
 * 
 * @deprecated Scheduled for removal in v1.0. Use {@link MeshLoadResult} instead.
 * Check with `MeshLoadResult.status === 'success'`.
 * 
 * @example
 * ```typescript
 * // Legacy code (deprecated)
 * if (result.ok) {
 *   console.log(result.asset);
 * }
 * 
 * // New code (recommended)
 * if (result.status === 'success') {
 *   console.log(result.asset);
 * }
 * ```
 * 
 * @see MeshLoadResult
 */
export interface MeshLoadSuccess {
  /** Success flag (always true) - Replaced by MeshLoadResult.status */
  ok: true;
  /** Loaded asset */
  asset: MeshAsset;
  /** Telemetry information - Replaced by AdapterMetrics */
  telemetry: MeshLoadTelemetry;
}

/**
 * Failure Result (Legacy)
 * 
 * @deprecated Scheduled for removal in v1.0. Use {@link MeshLoadResult} instead.
 * Check with `MeshLoadResult.status === 'error'`.
 * 
 * @example
 * ```typescript
 * // Legacy code (deprecated)
 * if (!result.ok) {
 *   console.error(result.error);
 * }
 * 
 * // New code (recommended)
 * if (result.status === 'error') {
 *   console.error(result.error.code);
 * }
 * ```
 * 
 * @see MeshLoadResult
 */
export interface MeshLoadFailure {
  /** Success flag (always false) - Replaced by MeshLoadResult.status */
  ok: false;
  /** Error code - Replaced by AdapterErrorCode */
  error: MeshLoadErrorCode;
  /** Error message - Replaced by AdapterError.message */
  message: string;
}

/**
 * Legacy Load Result Type (Legacy)
 * 
 * @deprecated Scheduled for removal in v1.0. Use {@link MeshLoadResult} instead.
 * The new type provides richer error information, metrics, and logs.
 * 
 * @example
 * ```typescript
 * // Legacy code (deprecated)
 * const result: LegacyMeshLoadResult = await legacyLoad(file);
 * if (result.ok) {
 *   console.log(result.asset);
 * } else {
 *   console.error(result.error);
 * }
 * 
 * // New code (recommended)
 * const result: MeshLoadResult = await adapter.load(file);
 * if (result.status === 'success') {
 *   console.log(result.asset);
 * } else {
 *   console.error(result.error.code);
 * }
 * ```
 * 
 * @see MeshLoadResult
 */
export type LegacyMeshLoadResult = MeshLoadSuccess | MeshLoadFailure;

// ============================================================================
// Clipping Types (004-mesh-cross-section)
// ============================================================================

/**
 * Clipping Plane Axis Direction
 * 
 * - `x`: Plane perpendicular to X-axis (YZ plane)
 * - `y`: Plane perpendicular to Y-axis (XZ plane) - Default for dental scan data
 * - `z`: Plane perpendicular to Z-axis (XY plane)
 */
export type ClippingAxis = 'x' | 'y' | 'z';

/**
 * Clipping Mode
 * - 'axis': Axis-aligned mode (X/Y/Z)
 * - 'free': Free plane mode (arbitrary angle)
 */
export type ClippingMode = 'axis' | 'free';

/**
 * Gizmo Manipulation Mode
 * - 'translate': Translation mode (Z-axis only)
 * - 'rotate': Rotation mode (X/Y axes)
 */
export type GizmoMode = 'translate' | 'rotate';

/**
 * Clipping State
 * 
 * Shared between Three.js GPU clipping and C++ sliceMesh algorithm.
 * Stores rotation as quaternion to prevent gimbal lock.
 * 
 * @example
 * ```typescript
 * // Axis-aligned mode (existing behavior)
 * const axisClipping: ClippingState = {
 *   enabled: true,
 *   mode: 'axis',
 *   axis: 'y',
 *   position: 50,
 *   flipped: false,
 *   quaternion: [0, 0, 0, 1],
 * };
 * 
 * // Free plane mode (new)
 * const freeClipping: ClippingState = {
 *   enabled: true,
 *   mode: 'free',
 *   axis: 'y',  // For fallback
 *   position: 50,
 *   flipped: false,
 *   quaternion: [0.383, 0, 0, 0.924],  // 45-degree X-axis rotation
 *   lastFreeQuaternion: [0.383, 0, 0, 0.924],
 * };
 * ```
 */
export interface ClippingState {
  /** Whether clipping is enabled */
  enabled: boolean;

  /** Clipping mode (axis: axis-aligned, free: free plane) */
  mode: ClippingMode;
  
  /** Clipping axis (for axis mode) */
  axis: ClippingAxis;

  /** Plane rotation - quaternion [x, y, z, w] */
  quaternion: [number, number, number, number];
  
  /** Slider position (0~100%) - relative to bounding box */
  position: number;
  
  /** Direction flip flag (default false: keep positive direction) */
  flipped: boolean;

  /** Last free plane quaternion - for restoration when switching modes */
  lastFreeQuaternion?: [number, number, number, number];
}

/**
 * Default Clipping State
 * 
 * Default axis: Y (vertical cutting is most common for dental scan data)
 * Default mode: axis (maintaining backward compatibility)
 */
export const DEFAULT_CLIPPING_STATE: ClippingState = {
  enabled: false,
  mode: 'axis',
  axis: 'y',
  quaternion: [0, 0, 0, 1],  // Identity quaternion
  position: 50,
  flipped: false,
};
